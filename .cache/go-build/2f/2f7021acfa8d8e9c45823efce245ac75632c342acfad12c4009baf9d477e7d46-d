// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/madhatter/Git/yay/src/gopath/pkg/mod/github.com/!jguer/go-alpm/v2@v2.2.2/package.go:1:1
// package.go - libalpm package type and methods.
//
// Copyright (c) 2013 The go-alpm Authors
//
// MIT Licensed. See LICENSE for details.

package alpm

/*
#include <alpm.h>

int pkg_cmp(const void *v1, const void *v2)
{
    alpm_pkg_t *p1 = (alpm_pkg_t *)v1;
    alpm_pkg_t *p2 = (alpm_pkg_t *)v2;
    off_t s1 = alpm_pkg_get_isize(p1);
    off_t s2 = alpm_pkg_get_isize(p2);

    if (s1 > s2)
        return -1;
    else if (s1 < s2)
        return 1;
    else
        return 0;
}
*/
import _ "unsafe"

import (
	"time"
	"unsafe"
)

// Package describes a single package and associated handle.
type Package struct {
	pmpkg  * /*line :36:10*/_Ctype_alpm_pkg_t /*line :36:22*/
	handle Handle
}

// PackageList describes a linked list of packages and associated handle.
type PackageList struct {
	*list
	handle Handle
}

// ForEach executes an action on each package of the PackageList.
func (l PackageList) ForEach(f func(IPackage) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		return f(&Package{(* /*line :49:23*/_Ctype_alpm_pkg_t /*line :49:35*/)(p), l.handle})
	})
}

// Slice converts the PackageList to a Package Slice.
func (l PackageList) Slice() []IPackage {
	slice := []IPackage{}
	_ = l.ForEach(func(p IPackage) error {
		slice = append(slice, p)
		return nil
	})

	return slice
}

// DependList describes a linkedlist of dependency type packages.
type DependList struct{ *list }

// ForEach executes an action on each package of the DependList.
func (l DependList) ForEach(f func(*Depend) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		dep := convertDepend((* /*line :70:26*/_Ctype_alpm_depend_t /*line :70:41*/)(p))
		return f(dep)
	})
}

// Slice converts the DependList to a Depend Slice.
func (l DependList) Slice() []Depend {
	slice := []Depend{}
	_ = l.ForEach(func(dep *Depend) error {
		slice = append(slice, *dep)
		return nil
	})

	return slice
}

func (pkg *Package) FileName() string {
	return ( /*line :87:9*/_Cfunc_GoString /*line :87:18*/)(func() *_Ctype_char{ _cgo0 := /*line :87:44*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :87:54*/_Cfunc_alpm_pkg_get_filename(_cgo0); }())
}

func (pkg *Package) Base() string {
	return ( /*line :91:9*/_Cfunc_GoString /*line :91:18*/)(func() *_Ctype_char{ _cgo0 := /*line :91:40*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :91:50*/_Cfunc_alpm_pkg_get_base(_cgo0); }())
}

func (pkg *Package) Base64Signature() string {
	return ( /*line :95:9*/_Cfunc_GoString /*line :95:18*/)(func() *_Ctype_char{ _cgo0 := /*line :95:46*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :95:56*/_Cfunc_alpm_pkg_get_base64_sig(_cgo0); }())
}

func (pkg *Package) Validation() Validation {
	return Validation(func() _Ctype_int{ _cgo0 := /*line :99:46*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :99:56*/_Cfunc_alpm_pkg_get_validation(_cgo0); }())
}

// Architecture returns the package target Architecture.
func (pkg *Package) Architecture() string {
	return ( /*line :104:9*/_Cfunc_GoString /*line :104:18*/)(func() *_Ctype_char{ _cgo0 := /*line :104:40*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :104:50*/_Cfunc_alpm_pkg_get_arch(_cgo0); }())
}

// Backup returns a list of package backups.
func (pkg *Package) Backup() BackupList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :109:46*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :109:56*/_Cfunc_alpm_pkg_get_backup(_cgo0); }())
	return BackupList{(*list)(ptr)}
}

// BuildDate returns the BuildDate of the package.
func (pkg *Package) BuildDate() time.Time {
	t := func() _Ctype_alpm_time_t{ _cgo0 := /*line :115:32*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :115:42*/_Cfunc_alpm_pkg_get_builddate(_cgo0); }()
	return time.Unix(int64(t), 0)
}

// Conflicts returns the conflicts of the package as a DependList.
func (pkg *Package) Conflicts() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :121:49*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :121:59*/_Cfunc_alpm_pkg_get_conflicts(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// DB returns the package's origin database.
func (pkg *Package) DB() IDB {
	ptr := func() *_Ctype_struct__alpm_db_t{ _cgo0 := /*line :127:27*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :127:37*/_Cfunc_alpm_pkg_get_db(_cgo0); }()
	if ptr == nil {
		return nil
	}

	return &DB{ptr, pkg.handle}
}

// Depends returns the package's dependency list.
func (pkg *Package) Depends() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :137:47*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :137:57*/_Cfunc_alpm_pkg_get_depends(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// Depends returns the package's optional dependency list.
func (pkg *Package) OptionalDepends() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :143:50*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :143:60*/_Cfunc_alpm_pkg_get_optdepends(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// Depends returns the package's check dependency list.
func (pkg *Package) CheckDepends() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :149:52*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :149:62*/_Cfunc_alpm_pkg_get_checkdepends(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// Depends returns the package's make dependency list.
func (pkg *Package) MakeDepends() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :155:51*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :155:61*/_Cfunc_alpm_pkg_get_makedepends(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// Description returns the package's description.
func (pkg *Package) Description() string {
	return ( /*line :161:9*/_Cfunc_GoString /*line :161:18*/)(func() *_Ctype_char{ _cgo0 := /*line :161:40*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :161:50*/_Cfunc_alpm_pkg_get_desc(_cgo0); }())
}

// Files returns the file list of the package.
func (pkg *Package) Files() []File {
	cFiles := func() *_Ctype_struct__alpm_filelist_t{ _cgo0 := /*line :166:33*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :166:43*/_Cfunc_alpm_pkg_get_files(_cgo0); }()
	return convertFilelist(cFiles)
}

// ContainsFile checks if the path is in the package filelist
func (pkg *Package) ContainsFile(path string) (File, error) {
	return convertFile(func() *_Ctype_struct__alpm_file_t{ _cgo0 := func() *_Ctype_struct__alpm_filelist_t{ _cgo0 := /*line :172:67*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :172:77*/_Cfunc_alpm_pkg_get_files(_cgo0); }(); var _cgo1 *_Ctype_char = _Cfunc_CString /*line :172:88*/(path); _cgoCheckPointer(_cgo0, nil); return /*line :172:95*/_Cfunc_alpm_filelist_contains(_cgo0, _cgo1); }())
}

// Groups returns the groups the package belongs to.
func (pkg *Package) Groups() StringList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :177:46*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :177:56*/_Cfunc_alpm_pkg_get_groups(_cgo0); }())
	return StringList{(*list)(ptr)}
}

// ISize returns the package installed size.
func (pkg *Package) ISize() int64 {
	t := func() _Ctype_off_t{ _cgo0 := /*line :183:28*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :183:38*/_Cfunc_alpm_pkg_get_isize(_cgo0); }()
	return int64(t)
}

// InstallDate returns the package install date.
func (pkg *Package) InstallDate() time.Time {
	t := func() _Ctype_alpm_time_t{ _cgo0 := /*line :189:34*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :189:44*/_Cfunc_alpm_pkg_get_installdate(_cgo0); }()
	return time.Unix(int64(t), 0)
}

// Licenses returns the package license list.
func (pkg *Package) Licenses() StringList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :195:48*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :195:58*/_Cfunc_alpm_pkg_get_licenses(_cgo0); }())
	return StringList{(*list)(ptr)}
}

// SHA256Sum returns package SHA256Sum.
func (pkg *Package) SHA256Sum() string {
	return ( /*line :201:9*/_Cfunc_GoString /*line :201:18*/)(func() *_Ctype_char{ _cgo0 := /*line :201:45*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :201:55*/_Cfunc_alpm_pkg_get_sha256sum(_cgo0); }())
}

// MD5Sum returns package MD5Sum.
func (pkg *Package) MD5Sum() string {
	return ( /*line :206:9*/_Cfunc_GoString /*line :206:18*/)(func() *_Ctype_char{ _cgo0 := /*line :206:42*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :206:52*/_Cfunc_alpm_pkg_get_md5sum(_cgo0); }())
}

// Name returns package name.
func (pkg *Package) Name() string {
	return ( /*line :211:9*/_Cfunc_GoString /*line :211:18*/)(func() *_Ctype_char{ _cgo0 := /*line :211:40*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :211:50*/_Cfunc_alpm_pkg_get_name(_cgo0); }())
}

// Packager returns package packager name.
func (pkg *Package) Packager() string {
	return ( /*line :216:9*/_Cfunc_GoString /*line :216:18*/)(func() *_Ctype_char{ _cgo0 := /*line :216:44*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :216:54*/_Cfunc_alpm_pkg_get_packager(_cgo0); }())
}

// Provides returns DependList of packages provides by package.
func (pkg *Package) Provides() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :221:48*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :221:58*/_Cfunc_alpm_pkg_get_provides(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// Reason returns package install reason.
func (pkg *Package) Reason() PkgReason {
	reason := func() _Ctype_alpm_pkgreason_t{ _cgo0 := /*line :227:34*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :227:44*/_Cfunc_alpm_pkg_get_reason(_cgo0); }()
	return PkgReason(reason)
}

// Origin returns package origin.
func (pkg *Package) Origin() PkgFrom {
	origin := func() _Ctype_alpm_pkgfrom_t{ _cgo0 := /*line :233:34*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :233:44*/_Cfunc_alpm_pkg_get_origin(_cgo0); }()
	return PkgFrom(origin)
}

// Replaces returns a DependList with the packages this package replaces.
func (pkg *Package) Replaces() IDependList {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :239:48*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :239:58*/_Cfunc_alpm_pkg_get_replaces(_cgo0); }())
	return DependList{(*list)(ptr)}
}

// Size returns the packed package size.
func (pkg *Package) Size() int64 {
	t := func() _Ctype_off_t{ _cgo0 := /*line :245:27*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :245:37*/_Cfunc_alpm_pkg_get_size(_cgo0); }()
	return int64(t)
}

// URL returns the upstream URL of the package.
func (pkg *Package) URL() string {
	return ( /*line :251:9*/_Cfunc_GoString /*line :251:18*/)(func() *_Ctype_char{ _cgo0 := /*line :251:39*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :251:49*/_Cfunc_alpm_pkg_get_url(_cgo0); }())
}

// Version returns the package version.
func (pkg *Package) Version() string {
	return ( /*line :256:9*/_Cfunc_GoString /*line :256:18*/)(func() *_Ctype_char{ _cgo0 := /*line :256:43*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :256:53*/_Cfunc_alpm_pkg_get_version(_cgo0); }())
}

// ComputeRequiredBy returns the names of reverse dependencies of a package
func (pkg *Package) ComputeRequiredBy() []string {
	result := func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :261:42*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :261:52*/_Cfunc_alpm_pkg_compute_requiredby(_cgo0); }()
	requiredby := make([]string, 0)

	for i := (*list)(unsafe.Pointer(result)); i != nil; i = i.Next {
		if i.Data != nil {
			name := ( /*line :266:12*/_Cfunc_GoString /*line :266:21*/)((* /*line :266:25*/_Ctype_char /*line :266:31*/)(i.Data))
			requiredby = append(requiredby, name)

			func() { _cgo0 := /*line :269:11*/i.Data; _cgoCheckPointer(_cgo0, nil); /*line :269:18*/_Cfunc_free(_cgo0); }()
		}

		func() { _cgo0 := /*line :272:10*/unsafe.Pointer(i); _cgoCheckPointer(_cgo0, nil); /*line :272:28*/_Cfunc_free(_cgo0); }()
	}

	return requiredby
}

// ComputeOptionalFor returns the names of packages that optionally require the given package
func (pkg *Package) ComputeOptionalFor() []string {
	result := func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :280:43*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); return /*line :280:53*/_Cfunc_alpm_pkg_compute_optionalfor(_cgo0); }()
	optionalfor := make([]string, 0)

	for i := (*list)(unsafe.Pointer(result)); i != nil; i = i.Next {
		if i.Data != nil {
			name := ( /*line :285:12*/_Cfunc_GoString /*line :285:21*/)((* /*line :285:25*/_Ctype_char /*line :285:31*/)(i.Data))
			optionalfor = append(optionalfor, name)

			func() { _cgo0 := /*line :288:11*/i.Data; _cgoCheckPointer(_cgo0, nil); /*line :288:18*/_Cfunc_free(_cgo0); }()
		}

		func() { _cgo0 := /*line :291:10*/unsafe.Pointer(i); _cgoCheckPointer(_cgo0, nil); /*line :291:28*/_Cfunc_free(_cgo0); }()
	}

	return optionalfor
}

func (pkg *Package) ShouldIgnore() bool {
	result := func() _Ctype_int{ _cgo0 := /*line :298:37*/pkg.handle.ptr; _cgo1 := /*line :298:53*/pkg.pmpkg; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :298:63*/_Cfunc_alpm_pkg_should_ignore(_cgo0, _cgo1); }()
	return result == 1
}

func (pkg *Package) Type() string {
	return "alpm"
}

// SortBySize returns a PackageList sorted by size.
func (l PackageList) SortBySize() IPackageList {
	pkgList := (* /*line :308:15*/_Ctype_struct__alpm_list_t /*line :308:36*/)(unsafe.Pointer(l.list))

	pkgCache := (*list)(unsafe.Pointer(
		func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :311:21*/pkgList; var _cgo1 _Ctype_size_t = func() _Ctype_size_t{ _cgo0 := /*line :312:22*/pkgList; _cgoCheckPointer(_cgo0, nil); return /*line :312:30*/_Cfunc_alpm_list_count(_cgo0); }(); var _cgo2 *[0]byte = _Ctype_alpm_list_fn_cmp /*line :313:22*/(_Cgo_ptr(_Cfpvar_fp_pkg_cmp /*line :313:32*/)); _cgoCheckPointer(_cgo0, nil); return /*line :313:34*/_Cfunc_alpm_list_msort(_cgo0, _cgo1, _cgo2); }()))
	if pkgCache == nil {
		return nil
	}

	return PackageList{pkgCache, l.handle}
}
