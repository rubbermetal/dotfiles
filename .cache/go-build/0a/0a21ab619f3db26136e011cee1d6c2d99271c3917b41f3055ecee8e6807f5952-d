// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/madhatter/Git/yay/src/gopath/pkg/mod/github.com/!jguer/go-alpm/v2@v2.2.2/db.go:1:1
// db.go - Functions for database handling.
//
// Copyright (c) 2013 The go-alpm Authors
//
// MIT Licensed. See LICENSE for details.

package alpm

/*
#include <alpm.h>
#include <alpm_list.h>
*/
import _ "unsafe"

import (
	"fmt"
	"io"
	"unsafe"
)

// DB structure representing a alpm database.
type DB struct {
	ptr    * /*line :23:10*/_Ctype_alpm_db_t /*line :23:21*/
	handle Handle
}

// DBList structure representing a alpm database list.
type DBList struct {
	*list
	handle Handle
}

// ForEach executes an action on each DB.
func (l DBList) ForEach(f func(IDB) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		return f(&DB{(* /*line :36:18*/_Ctype_alpm_db_t /*line :36:29*/)(p), l.handle})
	})
}

// Slice converts DB list to DB slice.
func (l DBList) Slice() []IDB {
	slice := []IDB{}
	_ = l.ForEach(func(db IDB) error {
		slice = append(slice, db)
		return nil
	})

	return slice
}

// Append modifies a DB list by appending the given DB.
func (l *DBList) Append(db IDB) {
	cdblist := (* /*line :53:15*/_Ctype_alpm_list_t /*line :53:28*/)(unsafe.Pointer(l.list))
	cdb := unsafe.Pointer(db.(*DB).ptr)

	cdblist = func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :56:28*/cdblist; _cgo1 := /*line :56:37*/cdb; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :56:41*/_Cfunc_alpm_list_add(_cgo0, _cgo1); }()

	l.list = (*list)(unsafe.Pointer(cdblist))
}

// SyncDBByName finds a registered database by name.
func (h *Handle) SyncDBByName(name string) (db IDB, err error) {
	dblist, err := h.SyncDBs()
	if err != nil {
		return nil, err
	}

	_ = dblist.ForEach(func(b IDB) error {
		if b.Name() == name {
			db = b
			return io.EOF
		}
		return nil
	})

	if db != nil {
		return db, nil
	}

	return nil, fmt.Errorf("database %s not found", name)
}

// SyncDBListByDBName creates and returns a database list with a single
// database given by name.
func (h *Handle) SyncDBListByDBName(name string) (IDBList, error) {
	db, err := h.SyncDBByName(name)
	if err != nil {
		return nil, err
	}

	dblist := h.NewDBList()
	dblist.Append(db)

	return dblist, nil
}

// RegisterSyncDB Loads a sync database with given name and signature check level.
func (h *Handle) RegisterSyncDB(dbname string, siglevel SigLevel) (IDB, error) {
	cName := ( /*line :99:11*/_Cfunc_CString /*line :99:19*/)(dbname)

	defer func() func() { _cgo0 := /*line :101:15*/unsafe.Pointer(cName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :101:37*/_Cfunc_free(_cgo0); }}()()

	db := func() *_Ctype_struct__alpm_db_t{ _cgo0 := /*line :103:31*/h.ptr; var _cgo1 *_Ctype_char = /*line :103:38*/cName; var _cgo2 _Ctype_int = _Ctype_int /*line :103:50*/(siglevel); _cgoCheckPointer(_cgo0, nil); return /*line :103:61*/_Cfunc_alpm_register_syncdb(_cgo0, _cgo1, _cgo2); }()
	if db == nil {
		return nil, h.LastError()
	}

	return &DB{db, *h}, nil
}

func (db *DB) Unregister() error {
	ok := func() _Ctype_int{ _cgo0 := /*line :112:29*/db.ptr; _cgoCheckPointer(_cgo0, nil); return /*line :112:36*/_Cfunc_alpm_db_unregister(_cgo0); }()
	if ok != 0 {
		return db.handle.LastError()
	}

	return nil
}

func (h *Handle) UnregisterAllSyncDBs() error {
	ok := func() _Ctype_int{ _cgo0 := /*line :121:38*/h.ptr; _cgoCheckPointer(_cgo0, nil); return /*line :121:44*/_Cfunc_alpm_unregister_all_syncdbs(_cgo0); }()
	if ok != 0 {
		return h.LastError()
	}

	return nil
}

// Name returns name of the db
func (db *DB) Name() string {
	return ( /*line :131:9*/_Cfunc_GoString /*line :131:18*/)(func() *_Ctype_char{ _cgo0 := /*line :131:39*/db.ptr; _cgoCheckPointer(_cgo0, nil); return /*line :131:46*/_Cfunc_alpm_db_get_name(_cgo0); }())
}

// Servers returns host server URL.
func (db *DB) Servers() []string {
	ptr := unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :136:46*/db.ptr; _cgoCheckPointer(_cgo0, nil); return /*line :136:53*/_Cfunc_alpm_db_get_servers(_cgo0); }())

	return StringList{(*list)(ptr)}.Slice()
}

// SetServers sets server list to use.
func (db *DB) SetServers(servers []string) {
	func() _Ctype_int{ _cgo0 := /*line :143:24*/db.ptr; var _cgo1 *_Ctype_struct__alpm_list_t = /*line :143:32*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :143:36*/_Cfunc_alpm_db_set_servers(_cgo0, _cgo1); }()

	for _, srv := range servers {
		Csrv := ( /*line :146:11*/_Cfunc_CString /*line :146:19*/)(srv)

		func() _Ctype_int{ _cgo0 := /*line :148:24*/db.ptr; var _cgo1 *_Ctype_char = /*line :148:32*/Csrv; _cgoCheckPointer(_cgo0, nil); return /*line :148:37*/_Cfunc_alpm_db_add_server(_cgo0, _cgo1); }()
		func() { _cgo0 := /*line :149:10*/unsafe.Pointer(Csrv); _cgoCheckPointer(_cgo0, nil); /*line :149:31*/_Cfunc_free(_cgo0); }()
	}
}

// AddServers adds a string to the server list.
func (db *DB) AddServer(server string) {
	Csrv := ( /*line :155:10*/_Cfunc_CString /*line :155:18*/)(server)

	defer func() func() { _cgo0 := /*line :157:15*/unsafe.Pointer(Csrv); return func() { _cgoCheckPointer(_cgo0, nil); /*line :157:36*/_Cfunc_free(_cgo0); }}()()

	func() _Ctype_int{ _cgo0 := /*line :159:23*/db.ptr; var _cgo1 *_Ctype_char = /*line :159:31*/Csrv; _cgoCheckPointer(_cgo0, nil); return /*line :159:36*/_Cfunc_alpm_db_add_server(_cgo0, _cgo1); }()
}

// SetUsage sets the Usage of the database
func (db *DB) SetUsage(usage Usage) {
	func() _Ctype_int{ _cgo0 := /*line :164:22*/db.ptr; var _cgo1 _Ctype_int = _Ctype_int /*line :164:35*/(usage); _cgoCheckPointer(_cgo0, nil); return /*line :164:43*/_Cfunc_alpm_db_set_usage(_cgo0, _cgo1); }()
}

// Name searches a package in db.
func (db *DB) Pkg(name string) IPackage {
	cName := ( /*line :169:11*/_Cfunc_CString /*line :169:19*/)(name)

	defer func() func() { _cgo0 := /*line :171:15*/unsafe.Pointer(cName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :171:37*/_Cfunc_free(_cgo0); }}()()

	ptr := func() *_Ctype_struct__alpm_pkg_t{ _cgo0 := /*line :173:27*/db.ptr; var _cgo1 *_Ctype_char = /*line :173:35*/cName; _cgoCheckPointer(_cgo0, nil); return /*line :173:41*/_Cfunc_alpm_db_get_pkg(_cgo0, _cgo1); }()
	if ptr == nil {
		return nil
	}

	return &Package{ptr, db.handle}
}

// PkgCache returns the list of packages of the database
func (db *DB) PkgCache() IPackageList {
	pkgcache := (*list)(unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :183:60*/db.ptr; _cgoCheckPointer(_cgo0, nil); return /*line :183:67*/_Cfunc_alpm_db_get_pkgcache(_cgo0); }()))

	return PackageList{pkgcache, db.handle}
}

// Search returns a list of packages matching the targets.
// In case of error the Package List will be nil
func (db *DB) Search(targets []string) IPackageList {
	var (
		needles * /*line :192:12*/_Ctype_alpm_list_t /*line :192:25*/
		ret     * /*line :193:12*/_Ctype_alpm_list_t /*line :193:25*/
	)

	for _, str := range targets {
		needles = func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :197:29*/needles; _cgo1 := /*line :197:38*/unsafe.Pointer(_Cfunc_CString /*line :197:62*/(str)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :197:69*/_Cfunc_alpm_list_add(_cgo0, _cgo1); }()
	}

	ok := func() _Ctype_int{ _cgo0 := /*line :200:25*/db.ptr; _cgo1 := /*line :200:33*/needles; _cgoBase2 := /*line :200:42*/&ret; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :200:47*/_Cfunc_alpm_db_search(_cgo0, _cgo1, _cgo2); }()
	if ok != 0 {
		return PackageList{nil, db.handle}
	}

	func() { _cgo0 := /*line :205:19*/needles; _cgoCheckPointer(_cgo0, nil); /*line :205:27*/_Cfunc_alpm_list_free(_cgo0); }()

	return PackageList{(*list)(unsafe.Pointer(ret)), db.handle}
}

// PkgCachebyGroup returns a PackageList of packages belonging to a group
func (l DBList) FindGroupPkgs(name string) IPackageList {
	cName := ( /*line :212:11*/_Cfunc_CString /*line :212:19*/)(name)

	defer func() func() { _cgo0 := /*line :214:15*/unsafe.Pointer(cName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :214:37*/_Cfunc_free(_cgo0); }}()()

	pkglist := (* /*line :216:15*/_Ctype_struct__alpm_list_t /*line :216:36*/)(unsafe.Pointer(l.list))
	pkgcache := (*list)(unsafe.Pointer(func() *_Ctype_struct__alpm_list_t{ _cgo0 := /*line :217:60*/pkglist; var _cgo1 *_Ctype_char = /*line :217:69*/cName; _cgoCheckPointer(_cgo0, nil); return /*line :217:75*/_Cfunc_alpm_find_group_pkgs(_cgo0, _cgo1); }()))

	return PackageList{pkgcache, l.handle}
}
